using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using Unity.Collections;
using UnityEditor;
using UnityEngine;

namespace KillCam
{
    public class ProtoGenerateTool : EditorWindow
    {
        private static string protocolTxtC2S;
        private static string protocolTxtS2C;
        private static List<string> tempNetMsgTypes;
        
        [MenuItem("GameTools/Proto Generate Tool")]
        public static void Execute()
        {
            protocolTxtC2S = $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/C2S.txt";
            protocolTxtS2C = $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/S2C.txt";
            tempNetMsgTypes = new List<string>();
            GenerateCode(ParseProtocolDefs(protocolTxtC2S), 
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/Protocol_C2S.cs");
            GenerateCode(ParseProtocolDefs(protocolTxtS2C), 
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/Protocol_S2C.cs");
            GenerateNetworkMsgEnum($"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/NetworkMsgEnum.cs");
            GenerateNetworkHandle(
                $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/C_HandleNetworkMsgSystemTemplate.txt",
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/C_HandleNetworkMsgSystem_AutoGenerated.cs",
                "C2S");
            GenerateNetworkHandle(
                $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/S_HandleNetworkMsgSystemTemplate.txt",
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/S_HandleNetworkMsgSystem_AutoGenerated.cs",
                "S2C_");
            tempNetMsgTypes.Clear();
        }

        public static void GenerateNetworkHandle(string templatePath, string outputPath, string filter)
        {
            var text = File.ReadAllText(templatePath);
            var sb = new StringBuilder();
            foreach (var typeStr in tempNetMsgTypes)
            {
                if (typeStr.Contains(filter))
                {
                    continue;
                }

                sb.AppendLine($"case NetMsg.{typeStr}:");
                sb.AppendLine($"\t\t\t\t\t\t\tvar {typeStr} = new {typeStr}();");
                sb.AppendLine($"\t\t\t\t\t\t\t{typeStr}.Deserialize(reader);");
                sb.AppendLine($"\t\t\t\t\t\t\tvar ent = cmd.CreateEntity();");
                sb.AppendLine($"\t\t\t\t\t\t\tcmd.AddComponent(ent, {typeStr});");
                sb.AppendLine("\t\t\t\t\t\t\tbreak;");
            }

            var replace1 = text.Replace("#replace auto generate info#",
                System.DateTime.Now.ToString(CultureInfo.CurrentCulture));
            var replace = replace1.Replace("#replace your method#", sb.ToString());
            File.WriteAllText(outputPath, replace);
        }

        public static void GenerateNetworkMsgEnum(string outputPath)
        {
            List<string> netMsgList = new List<string>();
            var c2sDefs = ParseProtocolDefs(protocolTxtC2S);
            foreach (var def in c2sDefs)
            {
                netMsgList.Add(def.ProtocolName);
            }
            var s2cDefs = ParseProtocolDefs(protocolTxtS2C);
            foreach (var def in s2cDefs)
            {
                netMsgList.Add(def.ProtocolName);
            }

            var sb = new StringBuilder();
            sb.AppendLine($"// AutoGenerate -> {System.DateTime.Now}");
            sb.AppendLine();
            sb.AppendLine("namespace KillCam");
            sb.AppendLine("{");
                sb.AppendLine("\tpublic enum NetMsg");
                sb.AppendLine("\t{");
                foreach (var value in netMsgList)
                {
                    sb.AppendLine($"\t\t{value},");
                }
                sb.AppendLine("\t}");
            
            sb.AppendLine("}");
            File.WriteAllText(outputPath, sb.ToString());
            tempNetMsgTypes.AddRange(netMsgList);
        }

        public static List<ProtocolDef> ParseProtocolDefs(string filePath)
        {
            var result = new List<ProtocolDef>();
            var allLines = File.ReadAllLines(filePath);

            Dictionary<string, Type> buildInTypes = new Dictionary<string, Type>()
            {
                {"int", typeof(int)},
                {"float", typeof(float)},
                {"bool", typeof(bool)},
                {"string", typeof(string)},
                {"Vector3", typeof(UnityEngine.Vector3)},
                {"Quaternion", typeof(UnityEngine.Quaternion)},
                {"uint", typeof(uint)},
                {"long", typeof(long)},
                {"FixedString32Bytes", typeof(FixedString32Bytes)},
                {"FixedString64Bytes", typeof(FixedString64Bytes)},
            };

            ProtocolDef current = null;
            int index = -1;
            bool isParsingField = false;
            foreach (var line in allLines)
            {
                index++;
                if (string.IsNullOrWhiteSpace(line))
                {
                    continue;
                }

                if (line.StartsWith("{"))
                {
                    current = new ProtocolDef()
                    {
                        ProtocolName = allLines[index - 1],
                    };

                    if (current.ProtocolName.Contains("C2S"))
                    {
                        current.InterfaceName = "IClientSend";
                    }
                    else if (current.ProtocolName.Contains("S2C"))
                    {
                        current.InterfaceName = "IServerRpc";    
                    }
                    
                    isParsingField = true;
                }
                else if (line.StartsWith("}"))
                {
                    result.Add(current);
                    current = null;

                    isParsingField = false;
                } 
                else if (isParsingField)
                {
                    var fieldSpit = line.Split(':');
                    var fieldType = fieldSpit[0].Trim();
                    var fieldName = fieldSpit[1].Trim();
                    if (buildInTypes.TryGetValue(fieldType, out var type))
                    {
                        current.TypeToNames.Add((type, fieldName));
                    }
                    else
                    {
                        type = Type.GetType(fieldType);
                        if (type == null)
                        {
                            throw new Exception("failed to get type for " + fieldType);
                        }
                        
                        current.TypeToNames.Add((type, fieldName));
                    }
                }
            }

            return result;
        }

        public static void GenerateCode(List<ProtocolDef> defs, string outputPath)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"// AutoGenerate -> {System.DateTime.Now}");
            sb.AppendLine();
            sb.AppendLine("namespace KillCam");
            sb.AppendLine("{");
            
            foreach (var def in defs)
            {
                // 消息类型
                sb.AppendLine($"\tpublic struct {def.ProtocolName} : {def.InterfaceName}");
                sb.AppendLine("\t{");
                sb.AppendLine($"\t\tpublic const NetMsg Msg = NetMsg.{def.ProtocolName};");
                sb.AppendLine();
                // 字段
                foreach (var (fieldType, fieldName) in def.TypeToNames)
                {
                    sb.AppendLine($"\t\tpublic {fieldType} {fieldName};");
                }
                sb.AppendLine();
                // 序列化方法
                sb.AppendLine($"\t\tpublic void Serialize(FishNet.Serializing.Writer writer)");
                sb.AppendLine("\t\t{");
                // 序列化
                Dictionary<Type, string> writeMethodNames = new Dictionary<Type, string>()
                {
                    { typeof(int), "WriteInt32" },
                    { typeof(bool), "WriteBoolean" },
                    { typeof(string), "WriteStringAllocated" },
                    { typeof(Vector2), "WriteVector2" },
                    { typeof(Vector3), "WriteVector3" },
                    { typeof(Quaternion), "WriteQuaternion64" },
                    { typeof(float), "WriteSingle" },
                    { typeof(long), "WriteInt64" },
                    { typeof(FixedString32Bytes), "WriteFixedString32Bytes" },
                    { typeof(FixedString64Bytes), "WriteFixedString64Bytes" },
                };
                foreach (var (fieldType, fieldName) in def.TypeToNames)
                {
                    if (writeMethodNames.TryGetValue(fieldType, out var methodName))
                    {
                        // 内置类型
                        sb.AppendLine($"\t\t\twriter.{methodName}({fieldName});");
                    }
                    else
                    {
                        // 拓展类型
                        sb.AppendLine($"\t\t\twriter.Write{fieldType.Name}({fieldName});");
                    }
                }
                sb.AppendLine("\t\t}");
                sb.AppendLine();
                
                // 反序列化方法
                sb.AppendLine("\t\tpublic void Deserialize(FishNet.Serializing.Reader reader)");
                sb.AppendLine("\t\t{");
                Dictionary<Type, string> readMethodNames = new Dictionary<Type, string>()
                {
                    { typeof(int), "ReadInt32()" },
                    { typeof(bool), "ReadBoolean()" },
                    { typeof(string), "ReadStringAllocated()" },
                    { typeof(Vector2), "ReadVector2()" },
                    { typeof(Vector3), "ReadVector3()" },
                    { typeof(Quaternion), "ReadQuaternion64()" },
                    { typeof(float), "ReadSingle()" },
                    { typeof(FixedString32Bytes), "ReadFixedString32Bytes()" },
                    { typeof(FixedString64Bytes), "ReadFixedString64Bytes()" },
                };
                foreach (var (fieldType, fieldName) in def.TypeToNames)
                {
                    if (readMethodNames.TryGetValue(fieldType, out var methodName))
                    {
                        // 内置类型
                        sb.AppendLine($"\t\t\t{fieldName} = reader.{methodName};");
                    }
                    else
                    {
                        // 拓展类型
                        sb.AppendLine($"\t\t\t{fieldName} = reader.Read{fieldType.Name}();");
                    }
                }
                sb.AppendLine("\t\t}");
                
                // 接口实现
                sb.AppendLine();
                sb.AppendLine("\t\tpublic NetMsg GetMsgType() => Msg;");
                sb.AppendLine("\t}");
            }
            
            sb.AppendLine("}");
            
            File.WriteAllText(outputPath, sb.ToString());
        }

        public class ProtocolDef
        {
            public string ProtocolName;
            public string InterfaceName;
            public List<(Type, string)> TypeToNames = new List<(Type, string)>();
        }
    }
}