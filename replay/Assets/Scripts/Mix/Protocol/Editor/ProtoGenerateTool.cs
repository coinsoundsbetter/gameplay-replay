using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using Unity.Collections;
using UnityEditor;
using UnityEngine;

namespace KillCam
{
    public class ProtoGenerateTool : EditorWindow
    {
        private static string protocolTxtC2S;
        private static string protocolTxtS2C;
        private static Dictionary<string, List<string>> manualHandleInClient;
        private static Dictionary<string, List<string>> manualHandleInServer;
        private static List<string> tempNetMsgTypes;
        private static List<ProtocolDef> c2sProtoDefs;
        private static List<ProtocolDef> s2cProtoDefs;
        
        [MenuItem("GameTools/Proto Generate Tool")]
        public static void Execute()
        {
            protocolTxtC2S = $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/C2S.txt";
            protocolTxtS2C = $"{Application.dataPath}/Scripts/Mix/Protocol/Editor/S2C.txt";
            tempNetMsgTypes = new List<string>();
            manualHandleInClient = new Dictionary<string, List<string>>();
            manualHandleInServer = new Dictionary<string, List<string>>();
            c2sProtoDefs = ParseProtocolDefs(protocolTxtC2S);
            s2cProtoDefs = ParseProtocolDefs(protocolTxtS2C);
            SaveManualHandleInClient();
            SaveManualHandleInServer();
            GenerateCode(c2sProtoDefs, $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/Protocol_C2S.cs");
            GenerateCode(s2cProtoDefs, $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/Protocol_S2C.cs");
            GenerateNetworkMsgEnum($"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/NetworkMsgEnum.cs");
            GenerateHandleClientMsg($"{Application.dataPath}/Scripts/Mix/Protocol/Editor/S_HandleNetworkMsgSystemTemplate.txt",
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/S_HandleNetworkMsgSystem_AutoGenerated.cs",
                "S2C_");
            GenerateHandleServerMsg($"{Application.dataPath}/Scripts/Mix/Protocol/Editor/C_HandleNetworkMsgSystemTemplate.txt",
                $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/C_HandleNetworkMsgSystem_AutoGenerated.cs",
                "C2S");
            tempNetMsgTypes.Clear();
        }

        public static void SaveManualHandleInClient()
        {
            // 先解析自动生成的源协议
            string source = $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/C_HandleNetworkMsgSystem_AutoGenerated.cs";
            var allLines = File.ReadAllLines(source);
            foreach (var def in s2cProtoDefs)
            {
                if (def.IsManualHandle)
                {
                    var netMsg = def.ProtocolName.Trim();
                    List<string> saveLines = new List<string>();
                    bool isInSaving = false;
                    foreach (var line in allLines)
                    {
                        if (line.Contains($"case NetMsg.{netMsg}:"))
                        {
                            isInSaving = true;
                            saveLines.Add(line);
                        }
                        else if (isInSaving && line.Contains("break;"))
                        {
                            saveLines.Add(line);
                            break;
                        }
                        else if(isInSaving)
                        {
                            saveLines.Add(line);
                        }
                    }
                    manualHandleInClient.Add(netMsg, saveLines);
                }
            }
        }

        public static void SaveManualHandleInServer()
        {
            // 先解析自动生成的源协议
            string source = $"{Application.dataPath}/Scripts/Mix/Protocol/AutoGenerated/S_HandleNetworkMsgSystem_AutoGenerated.cs";
            var allLines = File.ReadAllLines(source);
            foreach (var def in s2cProtoDefs)
            {
                if (def.IsManualHandle)
                {
                    var netMsg = def.ProtocolName.Trim();
                    List<string> saveLines = new List<string>();
                    bool isInSaving = false;
                    foreach (var line in allLines)
                    {
                        if (line.Contains($"case NetMsg.{netMsg}:"))
                        {
                            isInSaving = true;
                            saveLines.Add(line);
                        }
                        else if (isInSaving && line.Contains("break;"))
                        {
                            saveLines.Add(line);
                            break;
                        }
                        else if(isInSaving)
                        {
                            saveLines.Add(line);
                        }
                    }
                    manualHandleInServer.Add(netMsg, saveLines);
                }
            }
        }

        // 客户端处理服务器的消息
        public static void GenerateHandleServerMsg(string templatePath, string outputPath, string filter)
        {
            var text = File.ReadAllText(templatePath);
            var sb = new StringBuilder();
            foreach (var typeStr in tempNetMsgTypes)
            {
                if (typeStr.Contains(filter))
                {
                    continue;
                }
                
                var typeStrTrim = typeStr.Trim();
                if (manualHandleInClient.TryGetValue(typeStrTrim, out var handleLines))
                {
                    foreach (var line in handleLines)
                    {
                        sb.AppendLine(line);
                    }
                    continue;
                }
                
                sb.AppendLine($"\t\t\t\t\t\tcase NetMsg.{typeStrTrim}:");
                sb.AppendLine($"\t\t\t\t\t\t\tvar {typeStrTrim} = new {typeStrTrim}();");
                sb.AppendLine($"\t\t\t\t\t\t\t{typeStrTrim}.Deserialize(reader);");
                sb.AppendLine($"\t\t\t\t\t\t\tvar {typeStrTrim}_Ent = cmd.CreateEntity();");
                sb.AppendLine($"\t\t\t\t\t\t\tcmd.AddComponent({typeStrTrim}_Ent, {typeStr});");
                sb.AppendLine($"\t\t\t\t\t\t\tcmd.AddComponent({typeStrTrim}_Ent, new NetMsgTag());");
                sb.AppendLine("\t\t\t\t\t\t\tbreak;");
            }

            var replace1 = text.Replace("#replace auto generate info#",
                System.DateTime.Now.ToString(CultureInfo.CurrentCulture));
            var replace = replace1.Replace("#replace your method#", sb.ToString());
            File.WriteAllText(outputPath, replace);
        }

        // 服务器处理客户端的消息,需要客户端的命令帧号
        public static void GenerateHandleClientMsg(string templatePath, string outputPath, string filter)
        {
            var text = File.ReadAllText(templatePath);
            var sb = new StringBuilder();
            foreach (var typeStr in tempNetMsgTypes)
            {
                if (typeStr.Contains(filter))
                {
                    continue;
                }

                var typeStrTrim = typeStr.Trim();
                if (manualHandleInServer.TryGetValue(typeStrTrim, out var handleLines))
                {
                    foreach (var line in handleLines)
                    {
                        sb.AppendLine(line);
                    }
                    continue;
                }
                
                sb.AppendLine($"\t\t\t\t\t\tcase NetMsg.{typeStrTrim}:");
                sb.AppendLine($"\t\t\t\t\t\t\tvar {typeStrTrim} = new {typeStrTrim}();");
                sb.AppendLine($"\t\t\t\t\t\t\t{typeStrTrim}.Deserialize(reader);");
                sb.AppendLine($"\t\t\t\t\t\t\tvar {typeStrTrim}_Ent = cmd.CreateEntity();");
                sb.AppendLine($"\t\t\t\t\t\t\tcmd.AddComponent({typeStrTrim}_Ent, {typeStrTrim});");
                sb.AppendLine($"\t\t\t\t\t\t\tcmd.AddComponent({typeStrTrim}_Ent, new NetMsgTag());");
                sb.AppendLine("\t\t\t\t\t\t\tbreak;");
            }

            var replace1 = text.Replace("#replace auto generate info#",
                System.DateTime.Now.ToString(CultureInfo.CurrentCulture));
            var replace = replace1.Replace("#replace your method#", sb.ToString());
            File.WriteAllText(outputPath, replace);
        }

        public static void GenerateNetworkMsgEnum(string outputPath)
        {
            List<string> netMsgList = new List<string>();
            var c2sDefs = ParseProtocolDefs(protocolTxtC2S);
            foreach (var def in c2sDefs)
            {
                netMsgList.Add(def.ProtocolName);
            }
            var s2cDefs = ParseProtocolDefs(protocolTxtS2C);
            foreach (var def in s2cDefs)
            {
                netMsgList.Add(def.ProtocolName);
            }

            var sb = new StringBuilder();
            sb.AppendLine($"// AutoGenerate -> {System.DateTime.Now}");
            sb.AppendLine();
            sb.AppendLine("namespace KillCam");
            sb.AppendLine("{");
                sb.AppendLine("\tpublic enum NetMsg : uint ");
                sb.AppendLine("\t{");
                // 先生成C2S
                int index = -1;
                foreach (var def in c2sDefs)
                {
                    index++;
                    string name = def.ProtocolName.Trim();
                    sb.AppendLine($"\t\t{name} = {index},");
                }
                
                foreach (var def in s2cDefs)
                {
                    index++;
                    string name = def.ProtocolName.Trim();
                    sb.AppendLine($"\t\t{name} = {index},");
                }
                sb.AppendLine("\t}");
            
            sb.AppendLine("}");
            File.WriteAllText(outputPath, sb.ToString());
            tempNetMsgTypes.AddRange(netMsgList);
        }

        public static List<ProtocolDef> ParseProtocolDefs(string filePath)
        {
            var result = new List<ProtocolDef>();
            var allLines = File.ReadAllLines(filePath);

            ProtocolDef current = null;
            int index = -1;
            bool isParsingField = false;
            foreach (var line in allLines)
            {
                index++;
                if (string.IsNullOrWhiteSpace(line))
                {
                    continue;
                }

                if (line.StartsWith("{"))
                {
                    current = new ProtocolDef()
                    {
                        ProtocolName = allLines[index - 1],
                    };

                    if (index - 2 >= 0 && allLines[index - 2].Contains("[Manual]"))
                    {
                        current.IsManualHandle = true;
                    }

                    if (current.ProtocolName.Contains("C2S"))
                    {
                        current.InterfaceName = "IClientSend";
                    }
                    else if (current.ProtocolName.Contains("S2C"))
                    {
                        current.InterfaceName = "IServerRpc";    
                    }
                    
                    isParsingField = true;
                }
                else if (line.StartsWith("}"))
                {
                    result.Add(current);
                    current = null;

                    isParsingField = false;
                } 
                else if (isParsingField)
                {
                    var fieldSpit = line.Split(':');
                    var fieldType = fieldSpit[0].Trim();
                    var fieldName = fieldSpit[1].Trim();
                    current.TypeNameToFieldNames.Add((fieldType, fieldName));
                }
            }

            return result;
        }

        public static void GenerateCode(List<ProtocolDef> defs, string outputPath)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"// AutoGenerate -> {System.DateTime.Now}");
            sb.AppendLine();
            sb.AppendLine("namespace KillCam");
            sb.AppendLine("{");
            
            // 生成每个协议内容
            for (int i = 0; i < defs.Count; i++)
            {
                var def = defs[i];
                // 消息类型
                var protocolTrim = def.ProtocolName.Trim();
                sb.AppendLine($"\tpublic struct {protocolTrim} : {def.InterfaceName}");
                sb.AppendLine("\t{");
                sb.AppendLine($"\t\tpublic const NetMsg Msg = NetMsg.{protocolTrim};");
                sb.AppendLine();
                // 字段
                // 非C#内置但比较常用的Unity类型,用一个字典去映射它的类型声明
                Dictionary<string, string> fieldTypeToFullName = new Dictionary<string, string>()
                {
                    { "FixedString32Bytes", typeof(FixedString32Bytes).FullName },
                    { "FixedString64Bytes", typeof(FixedString64Bytes).FullName },
                    { "Vector2", typeof(Vector2).FullName },
                    { "Vector3", typeof(Vector3).FullName },
                    { "Quaternion", typeof(Quaternion).FullName },
                };
                foreach (var (fieldTypeName, fieldName) in def.TypeNameToFieldNames)
                {
                    if (fieldTypeToFullName.TryGetValue(fieldTypeName, out var fullName))
                    {
                        sb.AppendLine($"\t\tpublic {fullName} {fieldName};");
                    }
                    else
                    {
                        sb.AppendLine($"\t\tpublic {fieldTypeName} {fieldName};");
                    }
                }
                sb.AppendLine();
                // 序列化方法
                sb.AppendLine($"\t\tpublic void Serialize(FishNet.Serializing.Writer writer)");
                sb.AppendLine("\t\t{");
                // 序列化
                Dictionary<string, string> writeMethodNames = new Dictionary<string, string>()
                {
                    { "int", "WriteInt32" },
                    { "uint", "WriteUInt32"},
                    { "bool", "WriteBoolean" },
                    { "string", "WriteStringAllocated" },
                    { "Vector2", "WriteVector2" },
                    { "Vector3", "WriteVector3" },
                    { "Quaternion", "WriteQuaternion64" },
                    { "float", "WriteSingle" },
                    { "long", "WriteInt64" },
                    { "FixedString32Bytes", "WriteFixedString32Bytes" },
                    { "FixedString64Bytes", "WriteFixedString64Bytes" },
                };
                foreach (var (fieldType, fieldName) in def.TypeNameToFieldNames)
                {
                    if (writeMethodNames.TryGetValue(fieldType, out var methodName))
                    {
                        // 内置类型
                        sb.AppendLine($"\t\t\twriter.{methodName}({fieldName});");
                    }
                    else
                    {
                        // 拓展类型
                        sb.AppendLine($"\t\t\twriter.Write{fieldType}({fieldName});");
                    }
                }
                sb.AppendLine("\t\t}");
                sb.AppendLine();
                
                // 反序列化方法
                sb.AppendLine("\t\tpublic void Deserialize(FishNet.Serializing.Reader reader)");
                sb.AppendLine("\t\t{");
                Dictionary<string, string> readMethodNames = new Dictionary<string, string>()
                {
                    { "int", "ReadInt32()" },
                    { "uint", "ReadUInt32()" },
                    { "bool", "ReadBoolean()" },
                    { "string", "ReadStringAllocated()" },
                    { "Vector2", "ReadVector2()" },
                    { "Vector3", "ReadVector3()" },
                    { "Quaternion", "ReadQuaternion64()" },
                    { "float", "ReadSingle()" },
                    { "FixedString32Bytes", "ReadFixedString32Bytes()" },
                    { "FixedString64Bytes", "ReadFixedString64Bytes()" },
                };
                foreach (var (fieldTypeName, fieldName) in def.TypeNameToFieldNames)
                {
                    if (readMethodNames.TryGetValue(fieldTypeName, out var methodName))
                    {
                        // 内置类型
                        sb.AppendLine($"\t\t\t{fieldName} = reader.{methodName};");
                    }
                    else
                    {
                        // 拓展类型
                        sb.AppendLine($"\t\t\t{fieldName} = reader.Read{fieldTypeName}();");
                    }
                }
                sb.AppendLine("\t\t}");
                
                // 接口实现
                sb.AppendLine();
                sb.AppendLine("\t\tpublic NetMsg GetMsgType() => Msg;");
                sb.AppendLine("\t}");
                
                if (i < defs.Count - 1)
                {
                    sb.AppendLine();
                }
            }
            
            sb.AppendLine("}");
            
            File.WriteAllText(outputPath, sb.ToString());
        }

        public class ProtocolDef
        {
            public string ProtocolName;
            public string InterfaceName;
            public bool IsManualHandle;
            public List<(string, string)> TypeNameToFieldNames = new();
        }
    }
}